# coding=utf-8

import numpy as np
import tensorflow as tf
import tensorflow_probability as tfp

from gan_loss import get_loss_fn

tfd = tfp.distributions


class MusicGan(object):
    """Music GAN."""

    def __init__(self, generator, discriminator):
        self._generator = generator
        self._discriminator = discriminator

        self._global_step = None
        self._hparams = None
        self._mvn = None
        self._loss_fn = None
        self._real_data = None
        self._fake_data = None
        self._g_l = None
        self._d_l = None
        self._d_r_o = None
        self._d_f_o = None
        self._d_vars = None
        self._g_vars = None

    def build(self, hparams, output_depth, is_training=True, is_transform=False):
        """Builds generator and discriminator.

        :param hparams: An HParams object containing model hyperparameters. See
            `get_default_hparams` below for required values.
        :param output_depth: Size of the generator's output.
            It usually is decided by trick and pitch of the generated music.
            It's set as False, when use the pre-trained MusicVAE.
        :param is_training: Specify whether or not train
        """
        self._global_step = tf.train.get_or_create_global_step()
        self._hparams = hparams
        if not is_transform:
            self._generator.build(hparams, output_depth, is_training=is_training)
        self._discriminator.build(hparams, is_training)

        # initial Multidimensional standard normal distribution
        z_size = hparams.z_size
        loc = [0] * z_size
        scale_diag = [1] * z_size
        self._mvn = tfd.MultivariateNormalDiag(
            loc=loc,
            scale_diag=scale_diag)

    @property
    def generator(self):
        return self._generator

    @generator.setter
    def generator(self, value):
        self._generator = value

    @property
    def discriminator(self):
        return self._discriminator

    @property
    def global_step(self):
        return self._global_step

    @property
    def hparams(self):
        return self._hparams

    @property
    def mvn(self):
        return self._mvn

    @property
    def loss_fn(self):
        return self._loss_fn

    @property
    def real_data(self):
        return self._real_data

    @property
    def fake_data(self):
        return self._fake_data

    @property
    def gen_loss(self):
        return self._g_l

    @gen_loss.setter
    def gen_loss(self, value):
        self._g_l = value

    @property
    def dis_loss(self):
        return self._d_l

    @property
    def dis_real_data_output(self):
        return self._d_r_o

    @property
    def dis_fake_data_output(self):
        return self._d_f_o

    @property
    def gen_vars(self):
        return self._g_vars

    @property
    def dis_vars(self):
        return self._d_vars

    def generate(self, n, z):
        """Use generator to generate music.

        Note that z and result are tensor objects.

        :param n: the number of music that will be generated.
        :param z: Batch of latent vectors, used to guide music generation
            [n, z_size]
        :return: Generate music samples.
            [n, max_length, output_depth]
        """
        if n != z.shape[0]:
            raise ValueError("z.shape[0] must be equal n!")
        max_length = self._hparams.max_seq_len
        return self._generator.generate(z, max_length)

    def discriminate(self, data_inputs, sequence_length):
        """Use discriminator to discriminate true and false of input musics.

        :param data_inputs: discriminator's input, contains real data and fake data(generated by generator).
            [batch_size, bar_num×beat_num, pitch_d]
        :param sequence_length:
        :return the result of discriminator.
            [batch_size]
        """
        return self._discriminator.discriminate(data_inputs, sequence_length)

    def train(self, input_sequence, sequence_length):
        """Train MusicGAN model.

        :param input_sequence: Truly data(music) input, it's used by the discriminator.
            [batch_size, bar_num×beat_num, pitch_d]
        :param sequence_length
        :return optimizer: A tf.train.Optimizer.
        """
        hparams = self.hparams
        batch_size = hparams.batch_size

        # setting gan's loss function
        self._loss_fn = get_loss_fn(self.hparams.loss_fn)

        # get z
        z = self.mvn.sample(batch_size)

        # use generator
        real_data = input_sequence
        real_data_lengths = sequence_length
        real_data = tf.cast(real_data, tf.float32)
        fake_data, fake_data_lengths = self.generate(batch_size, z)
        self._real_data = real_data
        self._fake_data = fake_data

        # use discriminator
        discriminator_real_outputs = self.discriminate(real_data, real_data_lengths)

        # discriminator_fake_outputs = self.discriminate(fake_data, fake_data_lengths)

        # fake_data 为对数几率，需要先 softmax
        discriminator_fake_outputs = self.discriminate(tf.nn.softmax(fake_data), fake_data_lengths)

        self._d_r_o = discriminator_real_outputs
        self._d_f_o = discriminator_fake_outputs

        # compute loss
        generator_loss, discriminator_loss = self.loss_fn(discriminator_real_outputs, discriminator_fake_outputs)
        self._g_l = generator_loss
        self._d_l = discriminator_loss

        # collect variable
        self._d_vars = self.discriminator.get_all_variables()
        self._g_vars = self.generator.get_all_variables()

        tf.summary.scalar("g_loss", generator_loss)
        tf.summary.scalar("d_loss", discriminator_loss)
        tf.summary.scalar("w_estimator", -discriminator_loss)

        return generator_loss, discriminator_loss

    def gen_pre_train(self, x_inputs, x_targets, x_length):
        """

        :param x_inputs:
        :param x_targets:
        :param x_length:
        :return:
        """
        max_seq_len = self.hparams.max_seq_len
        z_size = self.hparams.z_size
        return self._generator.pre_train(x_inputs, x_targets, x_length, max_seq_len, z_size)

    def dis_pre_train(self, true_data, true_data_length):
        """

        :param true_data:
        :param true_data_length:
        :return:
        """
        hparams = self.hparams
        batch_size = hparams.batch_size

        # get z
        z = self.mvn.sample(batch_size)
        fake_data, fake_data_lengths = self.generate(batch_size, z)
        fake_data = tf.nn.softmax(fake_data)
        data_inputs = tf.concat([fake_data, true_data], axis=0)

        fake_labels = [[0, 1] for _ in range(batch_size)]
        true_labels = [[1, 0] for _ in range(batch_size)]
        data_labels = tf.convert_to_tensor(np.concatenate([fake_labels, true_labels], 0))
        data_labels = tf.to_float(data_labels)
        data_labels = tf.tile(tf.expand_dims(data_labels, axis=1), [1, tf.shape(data_inputs)[1], 1])

        data = tf.concat([data_inputs, data_labels], axis=-1)
        # shuffle
        # https://github.com/tensorflow/tensorflow/issues/6269
        data = tf.gather(data, tf.random.shuffle(tf.range(tf.shape(data)[0])))

        data_inputs, data_labels = tf.split(data, [-1, 2], axis=2)
        data_labels = data_labels[:, :1, :]
        data_labels = tf.squeeze(data_labels, axis=1)

        sequence_length = tf.concat([fake_data_lengths, true_data_length], axis=0)

        return self._discriminator.pre_train(data_inputs, data_labels, sequence_length)


def get_default_hparams():
    """Specify lots of default values of configurations"""
    return tf.contrib.training.HParams(
        max_seq_len=32,  # Maximum sequence length. Others will be truncated.
        z_size=32,  # Size of latent vector z.
        batch_size=512,  # Mini batch size.
        learning_rate=0.001,  # Learning rate.
        decay_rate=0.9999,  # Learning rate decay per mini batch.
        min_learning_rate=0.00001,  # Minimum learning rate.

        # GAN
        loss_fn='classic',  # specify GAN loss function
        bar_num=16,  # specify the number of bar per a music
        beat_num=16,  # specify the number of beat per a bar
        pitch_num=90,
        tracks_num=1,  # specify the number of audio track

        is_gen_pre_train=False,
        is_dis_pre_train=False,

        # generator
        gen_residual=False,
        gen_dropout_keep_prob=0.3,
        gen_pre_train_num=100,
        gen_repeat_num=1,

        # discriminator
        dis_residual=False,
        dis_pre_train_num=50,
        dis_repeat_num=5,  # specify discriminator repeated training times, when it is in initial state

    )
